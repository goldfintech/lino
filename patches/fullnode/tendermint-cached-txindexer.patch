diff --git a/CHANGELOG_PENDING.md b/CHANGELOG_PENDING.md
index f211a27f..c43b4e25 100644
--- a/CHANGELOG_PENDING.md
+++ b/CHANGELOG_PENDING.md
@@ -19,3 +19,5 @@
 ### IMPROVEMENTS:
 
 ### BUG FIXES:
+- [libs/db] Fixed the BoltDB backend's Batch.Delete implementation (@Yawning)
+- [libs/db] Fixed the BoltDB backend's Get and Iterator implementation (@Yawning)
diff --git a/consensus/replay.go b/consensus/replay.go
index 794f870d..e6f6fd28 100644
--- a/consensus/replay.go
+++ b/consensus/replay.go
@@ -17,6 +17,9 @@ import (
 	dbm "github.com/tendermint/tendermint/libs/db"
 	"github.com/tendermint/tendermint/libs/log"
 	"github.com/tendermint/tendermint/mock"
+	"github.com/tendermint/tendermint/state/txindex"
+	nulltxindexer "github.com/tendermint/tendermint/state/txindex/null"
+
 	"github.com/tendermint/tendermint/proxy"
 	sm "github.com/tendermint/tendermint/state"
 	"github.com/tendermint/tendermint/types"
@@ -203,6 +206,9 @@ type Handshaker struct {
 	genDoc       *types.GenesisDoc
 	logger       log.Logger
 
+	// indexer, null cacher if not set
+	txindexer txindex.TxIndexer
+
 	nBlocks int // number of blocks applied to the state
 }
 
@@ -216,6 +222,7 @@ func NewHandshaker(stateDB dbm.DB, state sm.State,
 		eventBus:     types.NopEventBus{},
 		genDoc:       genDoc,
 		logger:       log.NewNopLogger(),
+		txindexer:    &nulltxindexer.TxIndex{},
 		nBlocks:      0,
 	}
 }
@@ -224,6 +231,11 @@ func (h *Handshaker) SetLogger(l log.Logger) {
 	h.logger = l
 }
 
+// SetTxIndexer - sets tx indexer, if not called, nulltxinders.
+func (h *Handshaker) SetTxIndexer(indexer txindex.TxIndexer) {
+	h.txindexer = indexer
+}
+
 // SetEventBus - sets the event bus for publishing block related events.
 // If not called, it defaults to types.NopEventBus.
 func (h *Handshaker) SetEventBus(eventBus types.BlockEventPublisher) {
@@ -457,6 +469,9 @@ func (h *Handshaker) replayBlock(state sm.State, height int64, proxyApp proxy.Ap
 	blockExec := sm.NewBlockExecutor(h.stateDB, h.logger, proxyApp, mock.Mempool{}, sm.MockEvidencePool{})
 	blockExec.SetEventBus(h.eventBus)
 
+	// XXX(yumin): setTxIndexer for cache is required as fullnodes hit this path.
+	blockExec.SetTxIndexer(h.txindexer)
+
 	var err error
 	state, err = blockExec.ApplyBlock(state, meta.BlockID, block)
 	if err != nil {
diff --git a/libs/db/boltdb.go b/libs/db/boltdb.go
index 6bf474c8..30501dd8 100644
--- a/libs/db/boltdb.go
+++ b/libs/db/boltdb.go
@@ -66,7 +66,9 @@ func (bdb *BoltDB) Get(key []byte) (value []byte) {
 	key = nonEmptyKey(nonNilBytes(key))
 	err := bdb.db.View(func(tx *bbolt.Tx) error {
 		b := tx.Bucket(bucket)
-		value = b.Get(key)
+		if v := b.Get(key); v != nil {
+			value = append([]byte{}, v...)
+		}
 		return nil
 	})
 	if err != nil {
@@ -149,55 +151,45 @@ func (bdb *BoltDB) Stats() map[string]string {
 // boltDBBatch stores key values in sync.Map and dumps them to the underlying
 // DB upon Write call.
 type boltDBBatch struct {
-	buffer []struct {
-		k []byte
-		v []byte
-	}
-	db *BoltDB
+	db  *BoltDB
+	ops []operation
 }
 
 // NewBatch returns a new batch.
 func (bdb *BoltDB) NewBatch() Batch {
 	return &boltDBBatch{
-		buffer: make([]struct {
-			k []byte
-			v []byte
-		}, 0),
-		db: bdb,
+		ops: nil,
+		db:  bdb,
 	}
 }
 
 // It is safe to modify the contents of the argument after Set returns but not
 // before.
 func (bdb *boltDBBatch) Set(key, value []byte) {
-	bdb.buffer = append(bdb.buffer, struct {
-		k []byte
-		v []byte
-	}{
-		key, value,
-	})
+	bdb.ops = append(bdb.ops, operation{opTypeSet, key, value})
 }
 
 // It is safe to modify the contents of the argument after Delete returns but
 // not before.
 func (bdb *boltDBBatch) Delete(key []byte) {
-	for i, elem := range bdb.buffer {
-		if bytes.Equal(elem.k, key) {
-			// delete without preserving order
-			bdb.buffer[i] = bdb.buffer[len(bdb.buffer)-1]
-			bdb.buffer = bdb.buffer[:len(bdb.buffer)-1]
-			return
-		}
-	}
+	bdb.ops = append(bdb.ops, operation{opTypeDelete, key, nil})
 }
 
 // NOTE: the operation is synchronous (see BoltDB for reasons)
 func (bdb *boltDBBatch) Write() {
 	err := bdb.db.db.Batch(func(tx *bbolt.Tx) error {
 		b := tx.Bucket(bucket)
-		for _, elem := range bdb.buffer {
-			if putErr := b.Put(elem.k, elem.v); putErr != nil {
-				return putErr
+		for _, op := range bdb.ops {
+			key := nonEmptyKey(nonNilBytes(op.key))
+			switch op.opType {
+			case opTypeSet:
+				if putErr := b.Put(key, op.value); putErr != nil {
+					return putErr
+				}
+			case opTypeDelete:
+				if delErr := b.Delete(key); delErr != nil {
+					return delErr
+				}
 			}
 		}
 		return nil
@@ -322,12 +314,16 @@ func (itr *boltDBIterator) Next() {
 
 func (itr *boltDBIterator) Key() []byte {
 	itr.assertIsValid()
-	return itr.currentKey
+	return append([]byte{}, itr.currentKey...)
 }
 
 func (itr *boltDBIterator) Value() []byte {
 	itr.assertIsValid()
-	return itr.currentValue
+	var value []byte
+	if itr.currentValue != nil {
+		value = append([]byte{}, itr.currentValue...)
+	}
+	return value
 }
 
 func (itr *boltDBIterator) Close() {
diff --git a/node/node.go b/node/node.go
index 0d05deee..0e88e076 100644
--- a/node/node.go
+++ b/node/node.go
@@ -564,6 +564,9 @@ func NewNode(config *cfg.Config,
 		sm.BlockExecutorWithMetrics(smMetrics),
 	)
 
+	// set txIndexer
+	blockExec.SetTxIndexer(txIndexer)
+
 	// Make BlockchainReactor
 	bcReactor := bc.NewBlockchainReactor(state.Copy(), blockExec, blockStore, fastSync)
 	bcReactor.SetLogger(logger.With("module", "blockchain"))
diff --git a/state/execution.go b/state/execution.go
index 7e49a9ad..3baa45d3 100644
--- a/state/execution.go
+++ b/state/execution.go
@@ -10,6 +10,8 @@ import (
 	"github.com/tendermint/tendermint/libs/log"
 	mempl "github.com/tendermint/tendermint/mempool"
 	"github.com/tendermint/tendermint/proxy"
+	"github.com/tendermint/tendermint/state/txindex"
+	nulltxindexer "github.com/tendermint/tendermint/state/txindex/null"
 	"github.com/tendermint/tendermint/types"
 )
 
@@ -26,6 +28,9 @@ type BlockExecutor struct {
 	// execute the app against this
 	proxyApp proxy.AppConnConsensus
 
+	// indexer, null cacher if not set
+	txindexer txindex.TxIndexer
+
 	// events
 	eventBus types.BlockEventPublisher
 
@@ -51,13 +56,14 @@ func BlockExecutorWithMetrics(metrics *Metrics) BlockExecutorOption {
 // Call SetEventBus to provide one.
 func NewBlockExecutor(db dbm.DB, logger log.Logger, proxyApp proxy.AppConnConsensus, mempool mempl.Mempool, evpool EvidencePool, options ...BlockExecutorOption) *BlockExecutor {
 	res := &BlockExecutor{
-		db:       db,
-		proxyApp: proxyApp,
-		eventBus: types.NopEventBus{},
-		mempool:  mempool,
-		evpool:   evpool,
-		logger:   logger,
-		metrics:  NopMetrics(),
+		db:        db,
+		proxyApp:  proxyApp,
+		txindexer: &nulltxindexer.TxIndex{},
+		eventBus:  types.NopEventBus{},
+		mempool:   mempool,
+		evpool:    evpool,
+		logger:    logger,
+		metrics:   NopMetrics(),
 	}
 
 	for _, option := range options {
@@ -71,6 +77,11 @@ func (blockExec *BlockExecutor) DB() dbm.DB {
 	return blockExec.db
 }
 
+// SetTxIndexer - sets tx indexer, if not called, nulltxinders.
+func (blockExec *BlockExecutor) SetTxIndexer(indexer txindex.TxIndexer) {
+	blockExec.txindexer = indexer
+}
+
 // SetEventBus - sets the event bus for publishing block related events.
 // If not called, it defaults to types.NopEventBus.
 func (blockExec *BlockExecutor) SetEventBus(eventBus types.BlockEventPublisher) {
@@ -155,6 +166,16 @@ func (blockExec *BlockExecutor) ApplyBlock(state State, blockID types.BlockID, b
 		return state, fmt.Errorf("Commit failed for application: %v", err)
 	}
 
+	// XXX(yumin): this must happen before Commit to cache txs.
+	for i, tx := range block.Data.Txs {
+		blockExec.txindexer.Cache(&types.TxResult{
+			Height: block.Height,
+			Index:  uint32(i),
+			Tx:     tx,
+			Result: *(abciResponses.DeliverTx[i]),
+		})
+	}
+
 	// Lock mempool, commit app state, update mempoool.
 	appHash, err := blockExec.Commit(state, block, abciResponses.DeliverTx)
 	if err != nil {
diff --git a/state/txindex/indexer.go b/state/txindex/indexer.go
index ab509f96..c8aee640 100644
--- a/state/txindex/indexer.go
+++ b/state/txindex/indexer.go
@@ -9,6 +9,8 @@ import (
 
 // TxIndexer interface defines methods to index and search transactions.
 type TxIndexer interface {
+	// cache a result in memory, will be removed later if persisted in AddBatch.
+	Cache(result *types.TxResult)
 
 	// AddBatch analyzes, indexes and stores a batch of transactions.
 	AddBatch(b *Batch) error
diff --git a/state/txindex/kv/kv.go b/state/txindex/kv/kv.go
index 84208b8c..9de38181 100644
--- a/state/txindex/kv/kv.go
+++ b/state/txindex/kv/kv.go
@@ -7,11 +7,13 @@ import (
 	"sort"
 	"strconv"
 	"strings"
+	"sync"
 	"time"
 
 	"github.com/pkg/errors"
 	cmn "github.com/tendermint/tendermint/libs/common"
 	dbm "github.com/tendermint/tendermint/libs/db"
+	"github.com/tendermint/tendermint/libs/log"
 
 	"github.com/tendermint/tendermint/libs/pubsub/query"
 	"github.com/tendermint/tendermint/state/txindex"
@@ -20,6 +22,7 @@ import (
 
 const (
 	tagKeySeparator = "/"
+	cacheSizeMax    = 5000
 )
 
 var _ txindex.TxIndexer = (*TxIndex)(nil)
@@ -29,11 +32,16 @@ type TxIndex struct {
 	store        dbm.DB
 	tagsToIndex  []string
 	indexAllTags bool
+
+	logger   log.Logger
+	cache    map[string]types.TxResult
+	cacheMux sync.Mutex
 }
 
 // NewTxIndex creates new KV indexer.
 func NewTxIndex(store dbm.DB, options ...func(*TxIndex)) *TxIndex {
-	txi := &TxIndex{store: store, tagsToIndex: make([]string, 0), indexAllTags: false}
+	txi := &TxIndex{store: store, tagsToIndex: make([]string, 0), indexAllTags: false,
+		cache: make(map[string]types.TxResult)}
 	for _, o := range options {
 		o(txi)
 	}
@@ -54,6 +62,43 @@ func IndexAllTags() func(*TxIndex) {
 	}
 }
 
+func (txi *TxIndex) getFromCache(hash []byte) (types.TxResult, bool) {
+	txi.cacheMux.Lock()
+	defer txi.cacheMux.Unlock()
+	v, ok := txi.cache[string(hash)]
+	return v, ok
+}
+
+func (txi *TxIndex) removeFromCache(hash []byte) {
+	txi.cacheMux.Lock()
+	defer txi.cacheMux.Unlock()
+	if _, ok := txi.cache[string(hash)]; !ok {
+		if txi.logger != nil {
+			txi.logger.Error("[CachedTxIndexer] Removing non-existed hash")
+		} else {
+			fmt.Printf("%s\n", "[CachedTxIndexer] Removing non-existed hash")
+		}
+	}
+	delete(txi.cache, string(hash))
+}
+
+func (txi *TxIndex) Cache(result *types.TxResult) {
+	if result == nil {
+		return
+	}
+	txi.cacheMux.Lock()
+	defer txi.cacheMux.Unlock()
+	txi.cache[string(result.Tx.Hash())] = *result
+
+	if len(txi.cache) > cacheSizeMax {
+		if txi.logger != nil {
+			txi.logger.Error("TxIndexer cache size execeeds limit: %d", len(txi.cache))
+		} else {
+			fmt.Printf("TxIndexer cache size execeeds limit: %d\n", len(txi.cache))
+		}
+	}
+}
+
 // Get gets transaction from the TxIndex storage and returns it or nil if the
 // transaction is not found.
 func (txi *TxIndex) Get(hash []byte) (*types.TxResult, error) {
@@ -61,6 +106,10 @@ func (txi *TxIndex) Get(hash []byte) (*types.TxResult, error) {
 		return nil, txindex.ErrorEmptyHash
 	}
 
+	if v, ok := txi.getFromCache(hash); ok {
+		return &v, nil
+	}
+
 	rawBytes := txi.store.Get(hash)
 	if rawBytes == nil {
 		return nil, nil
@@ -104,6 +153,12 @@ func (txi *TxIndex) AddBatch(b *txindex.Batch) error {
 	}
 
 	storeBatch.Write()
+
+	// persisted, remove from cache
+	for _, result := range b.Ops {
+		txi.removeFromCache(result.Tx.Hash())
+	}
+
 	return nil
 }
 
diff --git a/state/txindex/null/null.go b/state/txindex/null/null.go
index f85de2e6..40c76be6 100644
--- a/state/txindex/null/null.go
+++ b/state/txindex/null/null.go
@@ -13,6 +13,9 @@ var _ txindex.TxIndexer = (*TxIndex)(nil)
 // TxIndex acts as a /dev/null.
 type TxIndex struct{}
 
+// Cache noop
+func (txi *TxIndex) Cache(result *types.TxResult) {}
+
 // Get on a TxIndex is disabled and panics when invoked.
 func (txi *TxIndex) Get(hash []byte) (*types.TxResult, error) {
 	return nil, errors.New(`Indexing is disabled (set 'tx_index = "kv"' in config)`)
