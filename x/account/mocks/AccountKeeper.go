// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import crypto "github.com/tendermint/tendermint/crypto"
import linotypes "github.com/lino-network/lino/types"
import mock "github.com/stretchr/testify/mock"
import types "github.com/cosmos/cosmos-sdk/types"

// AccountKeeper is an autogenerated mock type for the AccountKeeper type
type AccountKeeper struct {
	mock.Mock
}

// AddSavingCoin provides a mock function with given fields: ctx, username, coin, from, memo, detailType
func (_m *AccountKeeper) AddSavingCoin(ctx types.Context, username linotypes.AccountKey, coin linotypes.Coin, from linotypes.AccountKey, memo string, detailType linotypes.TransferDetailType) types.Error {
	ret := _m.Called(ctx, username, coin, from, memo, detailType)

	var r0 types.Error
	if rf, ok := ret.Get(0).(func(types.Context, linotypes.AccountKey, linotypes.Coin, linotypes.AccountKey, string, linotypes.TransferDetailType) types.Error); ok {
		r0 = rf(ctx, username, coin, from, memo, detailType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Error)
		}
	}

	return r0
}

// AddSavingCoinWithFullCoinDay provides a mock function with given fields: ctx, username, coin, from, memo, detailType
func (_m *AccountKeeper) AddSavingCoinWithFullCoinDay(ctx types.Context, username linotypes.AccountKey, coin linotypes.Coin, from linotypes.AccountKey, memo string, detailType linotypes.TransferDetailType) types.Error {
	ret := _m.Called(ctx, username, coin, from, memo, detailType)

	var r0 types.Error
	if rf, ok := ret.Get(0).(func(types.Context, linotypes.AccountKey, linotypes.Coin, linotypes.AccountKey, string, linotypes.TransferDetailType) types.Error); ok {
		r0 = rf(ctx, username, coin, from, memo, detailType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Error)
		}
	}

	return r0
}

// CreateAccount provides a mock function with given fields: ctx, referrer, username, resetKey, transactionKey, appKey, registerDeposit
func (_m *AccountKeeper) CreateAccount(ctx types.Context, referrer linotypes.AccountKey, username linotypes.AccountKey, resetKey crypto.PubKey, transactionKey crypto.PubKey, appKey crypto.PubKey, registerDeposit linotypes.Coin) types.Error {
	ret := _m.Called(ctx, referrer, username, resetKey, transactionKey, appKey, registerDeposit)

	var r0 types.Error
	if rf, ok := ret.Get(0).(func(types.Context, linotypes.AccountKey, linotypes.AccountKey, crypto.PubKey, crypto.PubKey, crypto.PubKey, linotypes.Coin) types.Error); ok {
		r0 = rf(ctx, referrer, username, resetKey, transactionKey, appKey, registerDeposit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Error)
		}
	}

	return r0
}

// DoesAccountExist provides a mock function with given fields: ctx, username
func (_m *AccountKeeper) DoesAccountExist(ctx types.Context, username linotypes.AccountKey) bool {
	ret := _m.Called(ctx, username)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Context, linotypes.AccountKey) bool); ok {
		r0 = rf(ctx, username)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetCoinDay provides a mock function with given fields: ctx, username
func (_m *AccountKeeper) GetCoinDay(ctx types.Context, username linotypes.AccountKey) (linotypes.Coin, types.Error) {
	ret := _m.Called(ctx, username)

	var r0 linotypes.Coin
	if rf, ok := ret.Get(0).(func(types.Context, linotypes.AccountKey) linotypes.Coin); ok {
		r0 = rf(ctx, username)
	} else {
		r0 = ret.Get(0).(linotypes.Coin)
	}

	var r1 types.Error
	if rf, ok := ret.Get(1).(func(types.Context, linotypes.AccountKey) types.Error); ok {
		r1 = rf(ctx, username)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(types.Error)
		}
	}

	return r0, r1
}

// MinusSavingCoin provides a mock function with given fields: ctx, username, coin, to, memo, detailType
func (_m *AccountKeeper) MinusSavingCoin(ctx types.Context, username linotypes.AccountKey, coin linotypes.Coin, to linotypes.AccountKey, memo string, detailType linotypes.TransferDetailType) types.Error {
	ret := _m.Called(ctx, username, coin, to, memo, detailType)

	var r0 types.Error
	if rf, ok := ret.Get(0).(func(types.Context, linotypes.AccountKey, linotypes.Coin, linotypes.AccountKey, string, linotypes.TransferDetailType) types.Error); ok {
		r0 = rf(ctx, username, coin, to, memo, detailType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Error)
		}
	}

	return r0
}

// MinusSavingCoinWithFullCoinDay provides a mock function with given fields: ctx, username, coin, to, memo, detailType
func (_m *AccountKeeper) MinusSavingCoinWithFullCoinDay(ctx types.Context, username linotypes.AccountKey, coin linotypes.Coin, to linotypes.AccountKey, memo string, detailType linotypes.TransferDetailType) (linotypes.Coin, types.Error) {
	ret := _m.Called(ctx, username, coin, to, memo, detailType)

	var r0 linotypes.Coin
	if rf, ok := ret.Get(0).(func(types.Context, linotypes.AccountKey, linotypes.Coin, linotypes.AccountKey, string, linotypes.TransferDetailType) linotypes.Coin); ok {
		r0 = rf(ctx, username, coin, to, memo, detailType)
	} else {
		r0 = ret.Get(0).(linotypes.Coin)
	}

	var r1 types.Error
	if rf, ok := ret.Get(1).(func(types.Context, linotypes.AccountKey, linotypes.Coin, linotypes.AccountKey, string, linotypes.TransferDetailType) types.Error); ok {
		r1 = rf(ctx, username, coin, to, memo, detailType)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(types.Error)
		}
	}

	return r0, r1
}
